import java.util.Comparator;

import components.map.Map;
import components.map.Map1L;
import components.queue.Queue;
import components.queue.Queue1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * A glossary webpage program from a text file
 *
 * @author Baowen Liu
 */
public final class Glossary {

    /**
     * Default constructor--private
     */
    private Glossary() {
        // no code needed here
    }

    /**
     * A comparator class that defines alphabetical ordering for glossary terms
     * based on the standard lexicographical order.
     */
    private static final class Sort implements Comparator<String> {
        @Override
        public int compare(String o1, String o2) {
            return o1.compareTo(o2);
        }
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>Glossary</title> </head> <body>
     * <h2>Glossary</h2>
     * <hr />
     * <h3>Index</h3>
     * <ul>
     *
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputIndexHeader(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";
        // HTML opening code
        out.println("<html>");
        out.println("<head>");
        out.println("<title>Glossary</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("   <h2>Glossary</h2>");
        out.println("   <hr/>");
        out.println("   <h3>Index</h3>");
        out.println("<ul>");

    }

    /**
     * Outputs the "closing" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * </ul>
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     *
     */
    private static void outputIndexFooter(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";
        // HTML closing code
        out.println("</ul>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Extract Glossary terms and their definitions.
     *
     * @param wordMap
     *            a map to store <term, definition> pairs
     * @param in
     *            the input reader connected to the glossary text file
     * @return a queue containing all the glossary terms in the order they
     *         appear
     */

    public static Queue<String> getDef(Map<String, String> wordMap, SimpleReader in) {
        // Create a queue to hold all the glossary terms
        Queue<String> termQueue = new Queue1L<>();
        // Loop through the entire input file
        while (!in.atEOS()) {
            // Read the term
            String term = in.nextLine();
            // Read the first line of the definition
            String def = in.nextLine();
            // Temporary string used to accumulate multi-line definitions
            String temp = " ";
            // Continue reading lines until an empty line or end of stream
            while (!in.atEOS() && temp.length() > 0) {
                temp = in.nextLine();
                // If the line is not empty, append it to the definition
                if (temp.length() > 0) {
                    def += temp;
                }
            }
            // Store the term and its definition in the map
            wordMap.add(term, def);
            // Add the term to the termQueue
            termQueue.enqueue(term);
        }
        return termQueue;
    }

    /**
     * Generates an individual HTML file for each glossary term. Each file
     * includes the term in red bold italic font, its definition, and a
     * hyperlink to return to the index page. The files are saved in the same
     * folder as the index.
     *
     * @param wordMap
     *            A map containing term-definition pairs
     * @param termQueue
     *            A queue containing all the glossary terms
     * @param out
     *            The path to the folder where HTML files should be saved
     * @requires termQueue and wordMaps are not empty
     * @ensures Creates one HTML file per term in the specified output folder.
     */
    public static void getUrls(Map<String, String> wordMap, Queue<String> termQueue,
            String out) {

        // Create a temporary queue to preserve the original termQueue content
        Queue<String> temp = new Queue1L<>();

        // Process each term in the queue
        while (termQueue.length() > 0) {
            // Read the current term
            String term = termQueue.dequeue();
            // Get the definition of the term from the map
            String def = wordMap.value(term);
            // Add the term to the temporary queue for later restoration
            temp.enqueue(term);

            // Create a new HTML file for the term
            SimpleWriter link = new SimpleWriter1L(out + "/" + term + ".html");

            // Begin writing HTML structure
            link.println("<html>");
            link.println("<head>");
            link.println("<title>" + term + "</title>");
            link.println("</head>");
            link.println("<body>");
            // Print the term styled in red, bold, and italic
            link.println(
                    "<h2><b><i><font color=\"red\">" + term + "</font></i></b></h2>");
            // Print the term's definition inside a blockquote
            link.println("<blockquote>" + def + "</blockquote>");
            // Horizontal line to separate content
            link.println("<hr />");
            // Link back to the index page
            link.println("<p>Return to <a href=\"index.html\">index</a>.</p>");

            // End HTML structure
            link.println("</body>");
            link.println("</html>");

            // Close the SimpleWriter;
            link.close();
        }
        // Restore the original termQueue by transferring back from temp
        termQueue.transferFrom(temp);
    }

    /**
     * Extracts the next word or sequence of separators from a given position in
     * the text.
     *
     * A "word" is defined as a sequence of characters that are not in the set
     * of separators. If the character at the starting position is a separator,
     * then a sequence of consecutive separators is returned. Otherwise, a
     * sequence of consecutive non-separator characters (i.e., a word) is
     * returned.
     *
     * This method is typically used to scan through a string (e.g., a glossary
     * definition) word by word, in order to identify terms and build
     * hyperlinks.
     *
     * @param text
     *            The full string to scan
     * @param position
     *            The index in the string to start scanning from
     * @param separators
     *            A set of designated separators
     * @return The next substring starting from the given position — either a
     *         word or separator(s)
     * @requires text is not null, separators is not null,
     *
     *           0 <= position < text.length()
     */
    public static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        // Initialize a string to accumulate the next word or separator sequence
        String nextWordOrSeparator = "";

        // Get the character at the starting position
        char b = text.charAt(position);

        // If the starting character is a separator
        if (separators.contains(b)) {
            // Extract all consecutive separators
            while (separators.contains(b) && position < text.length()) {
                // Append the current separator to the result
                b = text.charAt(position);
                nextWordOrSeparator += b;
                // Move to the next character
                position++;
            }
        } else {
            // Extract all consecutive non-separator characters (i.e., a word)
            while (!separators.contains(b) && position < text.length()) {
                // Append the current non-separator character to the result
                b = text.charAt(position);
                nextWordOrSeparator += b;
                // Move to the next character
                position++;

            }
        }
        return nextWordOrSeparator;
    }

    /**
     * Scans the definition text of each term and replaces any occurrence of
     * other glossary terms with an HTML hyperlink pointing to that term’s
     * definition page.
     *
     * @param wordMap
     *            A map storing <term, definition> pairs
     *
     * @param termQueue
     *            A queue of all glossary terms
     *
     * @param out
     *            The folder where HTML files will be saved
     *
     * @requires wordMap and termQueue are not empty;
     *
     *           All terms in termQueue are keys in wordMap
     *
     * @ensures For each definition in wordMap, any words matching glossary
     *          terms are replaced with hyperlinks; termQueue is restored to its
     *          original state
     */
    public static void definitionLink(Map<String, String> wordMap,
            Queue<String> termQueue, String out) {
        // Create a temporary queue to preserve original termQueue order
        Queue<String> temp = new Queue1L<>();
        // Define a set of characters considered as separators (e.g., space, punctuation)
        Set<Character> separators = new Set1L<>();

        // Define a set of characters considered as separators
        separators.add('.');
        separators.add(',');
        separators.add(' ');
        separators.add(':');
        separators.add('!');
        separators.add('?');

        // Initialize position variable used for scanning definitions
        int pos = 0;

        // Process each term in the queue
        while (termQueue.length() > 0) {
            // Get the terms at the beginning of termQueue
            String term = termQueue.dequeue();
            temp.enqueue(term);

            // Get the current definition associated with the term
            String definition = wordMap.value(term);
            // String to store the modified definition with links
            String finalDefinition = " ";

            // Scan through the definition word by word
            while (pos < definition.length()) {
                // Extract the next word or separator from the definition
                String word = nextWordOrSeparator(definition, pos, separators);
                // If this word is another glossary term, add an HTML hyperlink
                if (wordMap.hasKey(word)) {
                    finalDefinition += "<a href=\"" + word + ".html\">" + word + "</a>";
                } else {
                    // Otherwise, add the word or separator as-is
                    finalDefinition += word;
                }
                // Advance the position by the length of the current word or separator
                pos = pos + word.length();
            }
            // Update the map with the new definition, trimming the leading space
            wordMap.replaceValue(term, finalDefinition.substring(1));
            // Reset position
            pos = 0;
        }
        // Restore the original term queue
        termQueue.transferFrom(temp);
    }

    /**
     * Main method that drives the glossary generator program. It prompts the
     * user for the name of an input file and output folder. The input file
     * contains a list of glossary terms and their definitions.
     *
     * Example: A single term one line One or more lines of definition An empty
     * line separates each term-definition pair
     *
     * @param args
     *            Command-line arguments (not used)
     * @requires The input file must follow the format described above. The
     *           output file must already exist.
     * @ensures An index HTML file and one HTML page per term are created in the
     *          output folder.
     */
    public static void main(String[] args) {
        // Open the reader and writer stream
        SimpleReader userIn = new SimpleReader1L();
        SimpleWriter userOut = new SimpleWriter1L();

        // Print out the command for which file to read
        userOut.print("Enter input file: ");
        String input = userIn.nextLine();

        // Ask the user for where to save
        userOut.print("Enter a folder to save output file: ");
        String output = userIn.nextLine();

        // Open a reader to read terms and definitions
        SimpleReader in = new SimpleReader1L(input);
        // Open a writer to generate the index HTML page
        SimpleWriter out = new SimpleWriter1L(output + "/index.html");

        // Create a Map to store term-definition pairs
        Map<String, String> wordMap = new Map1L<>();
        // Create a Queue to store all terms for indexing and sorting
        Queue<String> termQueue = new Queue1L<>();

        // Extract terms and definitions from the file and populate wordMap and termQueue
        termQueue.append(getDef(wordMap, in));

        // Create a comparator to sort terms alphabetically
        Comparator<String> a = new Sort();
        // Sort the queue of terms alphabetically for the index page
        termQueue.sort(a);

        // Replace glossary terms found in definitions with HTML hyperlinks

        definitionLink(wordMap, termQueue, output);
        // Generate individual HTML pages for each glossary term
        getUrls(wordMap, termQueue, output);
        // Begin writing the index HTML page
        outputIndexHeader(out);

        // Write each sorted term as a linked list item in the index page
        while (termQueue.length() > 0) {
            String term = termQueue.dequeue();
            out.println("<li><a href=\"" + term + ".html\">" + term + "</a></li>");
        }
        // End of the HTML page
        outputIndexFooter(out);

        // Close all of the Simple readers and Simple Writers
        userIn.close();
        userOut.close();
        out.close();
    }
}
